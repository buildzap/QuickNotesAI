<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duplicate Calendar Events Cleanup</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        .test-section {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .log-output {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-success { background-color: #28a745; }
        .status-warning { background-color: #ffc107; }
        .status-error { background-color: #dc3545; }
        .status-info { background-color: #17a2b8; }
    </style>
</head>
<body>
    <div class="container mt-4">
        <h1><i class="bi bi-calendar-x me-2"></i>Duplicate Calendar Events Cleanup</h1>
        <p class="text-muted">Clean up existing duplicate calendar events and test the duplicate prevention fix</p>

        <!-- Status Overview -->
        <div class="test-section">
            <h3><i class="bi bi-info-circle me-2"></i>System Status</h3>
            <div id="systemStatus">
                <div class="mb-2">
                    <span class="status-indicator status-info"></span>
                    <span>Loading system status...</span>
                </div>
            </div>
        </div>

        <!-- Cleanup Controls -->
        <div class="test-section">
            <h3><i class="bi bi-broom me-2"></i>Cleanup Controls</h3>
            <div class="row">
                <div class="col-md-6">
                    <button class="btn btn-warning mb-2" onclick="scanForDuplicates()">
                        <i class="bi bi-search me-2"></i>Scan for Duplicates
                    </button>
                    <button class="btn btn-danger mb-2" onclick="cleanupAllDuplicates()">
                        <i class="bi bi-trash me-2"></i>Cleanup All Duplicates
                    </button>
                </div>
                <div class="col-md-6">
                    <button class="btn btn-success mb-2" onclick="testRecurringSync()">
                        <i class="bi bi-calendar-plus me-2"></i>Test Recurring Sync
                    </button>
                    <button class="btn btn-secondary mb-2" onclick="clearLog()">
                        <i class="bi bi-eraser me-2"></i>Clear Log
                    </button>
                </div>
            </div>
        </div>

        <!-- Manual Cleanup -->
        <div class="test-section">
            <h3><i class="bi bi-tools me-2"></i>Manual Cleanup</h3>
            <div class="row">
                <div class="col-md-6">
                    <div class="mb-3">
                        <label for="taskIdInput" class="form-label">Task ID:</label>
                        <input type="text" class="form-control" id="taskIdInput" placeholder="Enter task ID">
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="mb-3">
                        <label for="taskTitleInput" class="form-label">Task Title:</label>
                        <input type="text" class="form-control" id="taskTitleInput" placeholder="Enter task title">
                    </div>
                </div>
            </div>
            <button class="btn btn-primary" onclick="cleanupSpecificTask()">
                <i class="bi bi-calendar-check me-2"></i>Cleanup Specific Task
            </button>
        </div>

        <!-- Duplicate Events Found -->
        <div class="test-section">
            <h3><i class="bi bi-calendar-event me-2"></i>Duplicate Events Found</h3>
            <div id="duplicateEvents">
                <div class="text-muted">No duplicates scanned yet...</div>
            </div>
        </div>

        <!-- Log Output -->
        <div class="test-section">
            <h3><i class="bi bi-terminal me-2"></i>Log Output</h3>
            <div id="logOutput" class="log-output">Log will appear here...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="js/firebase-config.js"></script>
    <script src="js/firebase.js"></script>
    <script src="js/gcal.js"></script>
    <script src="js/task.js"></script>

    <script>
        let logMessages = [];

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] [${type.toUpperCase()}] ${message}`;
            logMessages.push(logEntry);
            
            const logOutput = document.getElementById('logOutput');
            if (logOutput) {
                logOutput.textContent = logMessages.join('\n');
                logOutput.scrollTop = logOutput.scrollHeight;
            }
            
            console.log(logEntry);
        }

        function clearLog() {
            logMessages = [];
            document.getElementById('logOutput').textContent = 'Log cleared...';
        }

        function updateSystemStatus() {
            const statusElement = document.getElementById('systemStatus');
            const status = [];

            // Check Firebase
            if (window.firebaseDb && window.firebaseAuth) {
                status.push('<span class="status-indicator status-success"></span><span>Firebase: Connected</span>');
            } else {
                status.push('<span class="status-indicator status-error"></span><span>Firebase: Not Connected</span>');
            }

            // Check Google Calendar
            if (window.gcal) {
                status.push('<span class="status-indicator status-success"></span><span>Google Calendar: Available</span>');
                if (window.gcal.isSignedIn && window.gcal.isSignedIn()) {
                    status.push('<span class="status-indicator status-success"></span><span>Google Calendar: Signed In</span>');
                } else {
                    status.push('<span class="status-indicator status-warning"></span><span>Google Calendar: Not Signed In</span>');
                }
            } else {
                status.push('<span class="status-indicator status-error"></span><span>Google Calendar: Not Available</span>');
            }

            statusElement.innerHTML = status.map(s => '<div class="mb-2">' + s + '</div>').join('');
        }

        async function scanForDuplicates() {
            try {
                log('Starting duplicate scan...', 'info');
                
                if (!window.gcal || !window.gcal.isSignedIn || !window.gcal.isSignedIn()) {
                    throw new Error('Google Calendar not connected');
                }

                // Get all recurring events from the last 30 days
                const events = await gapi.client.calendar.events.list({
                    calendarId: 'primary',
                    timeMin: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
                    timeMax: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),
                    singleEvents: false,
                    maxResults: 100,
                    q: 'ðŸ”„'
                });

                log(`Found ${events.result.items?.length || 0} recurring events`, 'info');

                // Group events by task ID
                const eventsByTaskId = {};
                const duplicates = [];

                events.result.items?.forEach(event => {
                    const taskId = event.extendedProperties?.private?.taskId;
                    if (taskId) {
                        if (!eventsByTaskId[taskId]) {
                            eventsByTaskId[taskId] = [];
                        }
                        eventsByTaskId[taskId].push(event);
                    }
                });

                // Find duplicates
                Object.keys(eventsByTaskId).forEach(taskId => {
                    if (eventsByTaskId[taskId].length > 1) {
                        duplicates.push({
                            taskId: taskId,
                            events: eventsByTaskId[taskId],
                            title: eventsByTaskId[taskId][0].summary
                        });
                    }
                });

                log(`Found ${duplicates.length} tasks with duplicate events`, duplicates.length > 0 ? 'warning' : 'success');

                // Display duplicates
                const duplicateElement = document.getElementById('duplicateEvents');
                if (duplicates.length === 0) {
                    duplicateElement.innerHTML = '<div class="text-success">No duplicate events found!</div>';
                } else {
                    const duplicateHtml = duplicates.map(dup => `
                        <div class="card mb-2">
                            <div class="card-body">
                                <h6 class="card-title">${dup.title}</h6>
                                <p class="card-text">
                                    <small class="text-muted">
                                        Task ID: ${dup.taskId}<br>
                                        Duplicate Events: ${dup.events.length}
                                    </small>
                                </p>
                                <button class="btn btn-sm btn-danger" onclick="cleanupTaskDuplicates('${dup.taskId}', '${dup.title}')">
                                    <i class="bi bi-trash me-1"></i>Cleanup
                                </button>
                            </div>
                        </div>
                    `).join('');
                    duplicateElement.innerHTML = duplicateHtml;
                }

            } catch (error) {
                log('Error scanning for duplicates: ' + error.message, 'error');
            }
        }

        async function cleanupAllDuplicates() {
            try {
                log('Starting cleanup of all duplicates...', 'info');
                
                if (!window.gcal || !window.gcal.isSignedIn || !window.gcal.isSignedIn()) {
                    throw new Error('Google Calendar not connected');
                }

                // Get all recurring events
                const events = await gapi.client.calendar.events.list({
                    calendarId: 'primary',
                    timeMin: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
                    timeMax: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(),
                    singleEvents: false,
                    maxResults: 100,
                    q: 'ðŸ”„'
                });

                // Group events by task ID
                const eventsByTaskId = {};
                events.result.items?.forEach(event => {
                    const taskId = event.extendedProperties?.private?.taskId;
                    if (taskId) {
                        if (!eventsByTaskId[taskId]) {
                            eventsByTaskId[taskId] = [];
                        }
                        eventsByTaskId[taskId].push(event);
                    }
                });

                let totalDeleted = 0;

                // Clean up duplicates for each task
                for (const taskId of Object.keys(eventsByTaskId)) {
                    const taskEvents = eventsByTaskId[taskId];
                    if (taskEvents.length > 1) {
                        log(`Cleaning up ${taskEvents.length - 1} duplicates for task ${taskId}`, 'info');
                        
                        // Keep the first event, delete the rest
                        for (let i = 1; i < taskEvents.length; i++) {
                            await gapi.client.calendar.events.delete({
                                calendarId: 'primary',
                                eventId: taskEvents[i].id
                            });
                            totalDeleted++;
                        }
                    }
                }

                log(`Cleanup completed! Deleted ${totalDeleted} duplicate events`, 'success');
                
                // Refresh the duplicate list
                setTimeout(scanForDuplicates, 1000);

            } catch (error) {
                log('Error cleaning up duplicates: ' + error.message, 'error');
            }
        }

        async function cleanupSpecificTask() {
            try {
                const taskId = document.getElementById('taskIdInput').value.trim();
                const taskTitle = document.getElementById('taskTitleInput').value.trim();

                if (!taskId || !taskTitle) {
                    log('Please enter both Task ID and Task Title', 'warning');
                    return;
                }

                log(`Cleaning up duplicates for task: ${taskTitle} (${taskId})`, 'info');

                if (!window.gcal || !window.gcal.cleanupDuplicateEvents) {
                    throw new Error('Google Calendar cleanup function not available');
                }

                const result = await window.gcal.cleanupDuplicateEvents(taskId, taskTitle);
                log(result.message, 'success');

            } catch (error) {
                log('Error cleaning up specific task: ' + error.message, 'error');
            }
        }

        async function cleanupTaskDuplicates(taskId, taskTitle) {
            try {
                log(`Cleaning up duplicates for: ${taskTitle}`, 'info');
                
                if (!window.gcal || !window.gcal.cleanupDuplicateEvents) {
                    throw new Error('Google Calendar cleanup function not available');
                }

                const result = await window.gcal.cleanupDuplicateEvents(taskId, taskTitle);
                log(result.message, 'success');
                
                // Refresh the duplicate list
                setTimeout(scanForDuplicates, 1000);

            } catch (error) {
                log('Error cleaning up task duplicates: ' + error.message, 'error');
            }
        }

        async function testRecurringSync() {
            try {
                log('Testing recurring sync with duplicate prevention...', 'info');
                
                if (!window.taskState || !window.taskState.tasks) {
                    throw new Error('No tasks available');
                }

                const recurringTasks = window.taskState.tasks.filter(t => t.recurring);
                if (recurringTasks.length === 0) {
                    throw new Error('No recurring tasks found');
                }

                const testTask = recurringTasks[0];
                log(`Testing sync with task: ${testTask.title}`, 'info');
                
                // Test the sync function
                await syncRecurringTaskToGoogleCalendar(testTask.id, testTask.title);
                log('Recurring sync test completed successfully', 'success');

            } catch (error) {
                log('Error testing recurring sync: ' + error.message, 'error');
            }
        }

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            log('Duplicate cleanup page loaded', 'info');
            
            setTimeout(() => {
                updateSystemStatus();
                log('Initial status check completed', 'info');
            }, 2000);
        });
    </script>
</body>
</html> 